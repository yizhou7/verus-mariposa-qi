use builtin_macros::*;
use builtin::*;
mod nl_basics;
use crate::nl_basics::*;
verus! {

pub proof fn inst_0(a0: int, b0: int, c0: int, d0: int,
a1: int, b1: int, c1: int, d1: int,
a2: int, b2: int, c2: int, d2: int,
a3: int, b3: int, c3: int, d3: int,
a4: int, b4: int, c4: int, d4: int,
a5: int, b5: int, c5: int, d5: int,
a6: int, b6: int, c6: int, d6: int,
a7: int, b7: int, c7: int, d7: int,
a8: int, b8: int, c8: int, d8: int,
a9: int, b9: int, c9: int, d9: int)
{
	let temp_0_0 = ((((a0*a0)*(a0*b0))+((d0*a0)*(c0*c0)))*(((b0*c0)*(d0+b0))*((a0*a0)*(c0*b0))));
	let temp_0_1 = ((((a0*a0)*(a0*b0))+(d0*(a0*(c0*c0))))*(((b0*c0)*(d0+b0))*((a0*a0)*(c0*b0))));
	assert(temp_0_0 == temp_0_1) by 
			{lemma_mul_is_associative(d0, a0, (c0*c0));}// 1
	let temp_1_0 = ((((d1*d1)*(b1*c1))*((d1*d1)*(a1+a1)))*(((a1*a1)*(d1*a1))+(c1*(d1*d1))));
	let temp_1_1 = ((((d1*d1)*(b1*c1))*((d1*d1)*(a1+a1)))*(((a1*a1)*(d1*a1))+(c1*(d1*d1))));
	assert(temp_1_0 == temp_1_1) by 
			{lemma_mul_is_commutative(d1, d1);}// 1
	let temp_2_0 = ((((b2*c2)*(b2*(10 as int)))*((b2+b2)*(a2*b2)))*(((a2*d2)*(a2*c2))*((a2*d2)*(b2*c2))));
	let temp_2_1 = ((((b2*c2)*(b2*(10 as int)))*((a2*b2)*(b2+b2)))*(((a2*d2)*(a2*c2))*((a2*d2)*(b2*c2))));
	assert(temp_2_0 == temp_2_1) by 
			{lemma_mul_is_commutative((b2+b2), (a2*b2));}// 1
	let temp_3_0 = ((((a3*c3)*(b3*c3))*((d3*d3)*(c3*b3)))+(((c3*d3)*(b3*d3))*(b3*(b3*a3))));
	let temp_3_1 = ((((a3*c3)*(b3*c3))*((d3*d3)*(c3*b3)))+((b3*(b3*a3))*((c3*d3)*(b3*d3))));
	assert(temp_3_0 == temp_3_1) by 
			{lemma_mul_is_commutative(((c3*d3)*(b3*d3)), (b3*(b3*a3)));}// 1
	let temp_4_0 = ((((b4*d4)*(a4*b4))*((b4*c4)*(a4+b4)))-(((a4*a4)*(c4+d4))-((c4*a4)*(d4*a4))));
	let temp_4_1 = ((((b4*d4)*(a4*b4))*((b4*c4)*(a4+b4)))-(((a4*a4)*(c4+d4))-((c4*a4)*(d4*a4))));
	assert(temp_4_0 == temp_4_1) by 
			{lemma_mul_is_commutative(a4, a4);}// 1
	let temp_5_0 = ((((a5+b5)*(c5*d5))*((d5*b5)*(a5*a5)))*(((d5*b5)*(d5*c5))*((a5*d5)*(a5*(4 as int)))));
	let temp_5_1 = ((((a5+b5)*(c5*d5))*(((d5*b5)*a5)*a5))*(((d5*b5)*(d5*c5))*((a5*d5)*(a5*(4 as int)))));
	assert(temp_5_0 == temp_5_1) by 
			{lemma_mul_is_associative((d5*b5), a5, a5);}// 1
	let temp_6_0 = ((((a6*d6)*(a6*c6))+((c6*c6)*(b6+a6)))*((a6+(d6*d6))*((d6*d6)-(a6*a6))));
	let temp_6_1 = (((a6+(d6*d6))*((d6*d6)-(a6*a6)))*(((a6*d6)*(a6*c6))+((c6*c6)*(b6+a6))));
	assert(temp_6_0 == temp_6_1) by 
			{lemma_mul_is_commutative((((a6*d6)*(a6*c6))+((c6*c6)*(b6+a6))), ((a6+(d6*d6))*((d6*d6)-(a6*a6))));}// 1
	let temp_7_0 = ((((c7*b7)*(b7*b7))*((d7*d7)*(d7*b7)))*(((d7*a7)*a7)+((d7*b7)*(c7+d7))));
	let temp_7_1 = ((((c7*b7)*(b7*b7))*(d7*(d7*(d7*b7))))*(((d7*a7)*a7)+((d7*b7)*(c7+d7))));
	assert(temp_7_0 == temp_7_1) by 
			{lemma_mul_is_associative(d7, d7, (d7*b7));}// 1

}

} // verus!